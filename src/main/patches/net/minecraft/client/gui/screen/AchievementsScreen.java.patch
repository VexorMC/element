--- AchievementsScreen.java
+++ AchievementsScreen.java
@@ -1,8 +1,8 @@
 package net.minecraft.client.gui.screen;
 
-import com.mojang.blaze3d.platform.GlStateManager;
+import com.mojang.blaze3d.platform.legacy.GlStateManager;
 import java.util.Random;
 import net.minecraft.advancement.Achievement;
 import net.minecraft.advancement.AchievementsAndCriterions;
 import net.minecraft.block.Block;
 import net.minecraft.block.Blocks;
@@ -16,11 +16,11 @@
 import net.minecraft.client.texture.SpriteAtlasTexture;
 import net.minecraft.network.packet.c2s.play.ClientStatusC2SPacket;
 import net.minecraft.stat.StatHandler;
 import net.minecraft.text.TranslatableText;
 import net.minecraft.util.Identifier;
-import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.Mth;
 import org.lwjgl.input.Mouse;
 
 public class AchievementsScreen extends Screen implements StatsListener {
 	private static final int MIN_PAN_X = AchievementsAndCriterions.minColumn * 24 - 112;
 	private static final int MIN_PAN_Y = AchievementsAndCriterions.minRow * 24 - 112;
@@ -111,19 +111,19 @@
 				}
 			} else {
 				this.isDragging = 0;
 			}
 
-			int k = Mouse.getDWheel();
+			int k = Mouse.getEventDWheel();
 			float g = this.fov;
 			if (k < 0) {
 				this.fov += 0.25F;
 			} else if (k > 0) {
 				this.fov -= 0.25F;
 			}
 
-			this.fov = MathHelper.clamp(this.fov, 1.0F, 2.0F);
+			this.fov = Mth.clamp(this.fov, 1.0F, 2.0F);
 			if (this.fov != g) {
 				float h = g - this.fov;
 				float o = g * (float)this.originX;
 				float p = g * (float)this.originY;
 				float q = this.fov * (float)this.originX;
@@ -189,12 +189,12 @@
 		int j = (this.height - this.originY) / 2;
 		this.textRenderer.draw(I18n.translate("gui.achievements"), i + 15, j + 5, 4210752);
 	}
 
 	protected void renderIcons(int i, int j, float f) {
-		int k = MathHelper.floor(this.attemptedCenterX + (this.targetCenterX - this.attemptedCenterX) * (double)f);
-		int l = MathHelper.floor(this.attemptedCenterY + (this.targetCenterY - this.attemptedCenterY) * (double)f);
+		int k = Mth.floor(this.attemptedCenterX + (this.targetCenterX - this.attemptedCenterX) * (double)f);
+		int l = Mth.floor(this.attemptedCenterY + (this.targetCenterY - this.attemptedCenterY) * (double)f);
 		if (k < MIN_PAN_X) {
 			k = MIN_PAN_X;
 		}
 
 		if (l < MIN_PAN_Y) {
