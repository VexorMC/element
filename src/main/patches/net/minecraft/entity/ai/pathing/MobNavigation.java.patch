--- MobNavigation.java
+++ MobNavigation.java
@@ -5,11 +5,11 @@
 import net.minecraft.block.material.Material;
 import net.minecraft.entity.mob.MobEntity;
 import net.minecraft.entity.mob.ZombieEntity;
 import net.minecraft.entity.passive.ChickenEntity;
 import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.Mth;
 import net.minecraft.util.math.Vec3d;
 import net.minecraft.world.World;
 
 public class MobNavigation extends EntityNavigation {
 	protected LandPathNodeMaker nodeMaker;
@@ -39,15 +39,15 @@
 	}
 
 	private int getPathfindingY() {
 		if (this.mob.isTouchingWater() && this.canSwim()) {
 			int i = (int)this.mob.getBoundingBox().minY;
-			Block block = this.world.getBlockState(new BlockPos(MathHelper.floor(this.mob.x), i, MathHelper.floor(this.mob.z))).getBlock();
+			Block block = this.world.getBlockState(new BlockPos(Mth.floor(this.mob.x), i, Mth.floor(this.mob.z))).getBlock();
 			int j = 0;
 
 			while (block == Blocks.FLOWING_WATER || block == Blocks.WATER) {
-				block = this.world.getBlockState(new BlockPos(MathHelper.floor(this.mob.x), ++i, MathHelper.floor(this.mob.z))).getBlock();
+				block = this.world.getBlockState(new BlockPos(Mth.floor(this.mob.x), ++i, Mth.floor(this.mob.z))).getBlock();
 				if (++j > 16) {
 					return (int)this.mob.getBoundingBox().minY;
 				}
 			}
 
@@ -59,11 +59,11 @@
 
 	@Override
 	protected void adjustPath() {
 		super.adjustPath();
 		if (this.avoidSunlight) {
-			if (this.world.hasDirectSunlight(new BlockPos(MathHelper.floor(this.mob.x), (int)(this.mob.getBoundingBox().minY + 0.5), MathHelper.floor(this.mob.z)))) {
+			if (this.world.hasDirectSunlight(new BlockPos(Mth.floor(this.mob.x), (int)(this.mob.getBoundingBox().minY + 0.5), Mth.floor(this.mob.z)))) {
 				return;
 			}
 
 			for (int i = 0; i < this.currentPath.getNodeCount(); i++) {
 				PathNode pathNode = this.currentPath.getNode(i);
@@ -75,12 +75,12 @@
 		}
 	}
 
 	@Override
 	protected boolean canPathDirectlyThrough(Vec3d vec3d, Vec3d vec3d2, int i, int j, int k) {
-		int l = MathHelper.floor(vec3d.x);
-		int m = MathHelper.floor(vec3d.z);
+		int l = Mth.floor(vec3d.x);
+		int m = Mth.floor(vec3d.z);
 		double d = vec3d2.x - vec3d.x;
 		double e = vec3d2.z - vec3d.z;
 		double f = d * d + e * e;
 		if (f < 1.0E-8) {
 			return false;
@@ -109,12 +109,12 @@
 
 				o /= d;
 				p /= e;
 				int q = d < 0.0 ? -1 : 1;
 				int r = e < 0.0 ? -1 : 1;
-				int s = MathHelper.floor(vec3d2.x);
-				int t = MathHelper.floor(vec3d2.z);
+				int s = Mth.floor(vec3d2.x);
+				int t = Mth.floor(vec3d2.z);
 				int u = s - l;
 				int v = t - m;
 
 				while (u * q > 0 || v * r > 0) {
 					if (o < p) {
