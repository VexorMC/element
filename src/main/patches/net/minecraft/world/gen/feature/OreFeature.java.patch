--- OreFeature.java
+++ OreFeature.java
@@ -4,11 +4,11 @@
 import java.util.Random;
 import net.minecraft.block.BlockState;
 import net.minecraft.block.Blocks;
 import net.minecraft.predicate.block.BlockPredicate;
 import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.Mth;
 import net.minecraft.world.World;
 
 public class OreFeature extends Feature {
 	private final BlockState blockState;
 	private final int amount;
@@ -25,31 +25,31 @@
 	}
 
 	@Override
 	public boolean generate(World world, Random random, BlockPos blockPos) {
 		float f = random.nextFloat() * (float) Math.PI;
-		double d = (double)((float)(blockPos.getX() + 8) + MathHelper.sin(f) * (float)this.amount / 8.0F);
-		double e = (double)((float)(blockPos.getX() + 8) - MathHelper.sin(f) * (float)this.amount / 8.0F);
-		double g = (double)((float)(blockPos.getZ() + 8) + MathHelper.cos(f) * (float)this.amount / 8.0F);
-		double h = (double)((float)(blockPos.getZ() + 8) - MathHelper.cos(f) * (float)this.amount / 8.0F);
+		double d = (double)((float)(blockPos.getX() + 8) + Mth.sin(f) * (float)this.amount / 8.0F);
+		double e = (double)((float)(blockPos.getX() + 8) - Mth.sin(f) * (float)this.amount / 8.0F);
+		double g = (double)((float)(blockPos.getZ() + 8) + Mth.cos(f) * (float)this.amount / 8.0F);
+		double h = (double)((float)(blockPos.getZ() + 8) - Mth.cos(f) * (float)this.amount / 8.0F);
 		double i = (double)(blockPos.getY() + random.nextInt(3) - 2);
 		double j = (double)(blockPos.getY() + random.nextInt(3) - 2);
 
 		for (int k = 0; k < this.amount; k++) {
 			float l = (float)k / (float)this.amount;
 			double m = d + (e - d) * (double)l;
 			double n = i + (j - i) * (double)l;
 			double o = g + (h - g) * (double)l;
 			double p = random.nextDouble() * (double)this.amount / 16.0;
-			double q = (double)(MathHelper.sin((float) Math.PI * l) + 1.0F) * p + 1.0;
-			double r = (double)(MathHelper.sin((float) Math.PI * l) + 1.0F) * p + 1.0;
-			int s = MathHelper.floor(m - q / 2.0);
-			int t = MathHelper.floor(n - r / 2.0);
-			int u = MathHelper.floor(o - q / 2.0);
-			int v = MathHelper.floor(m + q / 2.0);
-			int w = MathHelper.floor(n + r / 2.0);
-			int x = MathHelper.floor(o + q / 2.0);
+			double q = (double)(Mth.sin((float) Math.PI * l) + 1.0F) * p + 1.0;
+			double r = (double)(Mth.sin((float) Math.PI * l) + 1.0F) * p + 1.0;
+			int s = Mth.floor(m - q / 2.0);
+			int t = Mth.floor(n - r / 2.0);
+			int u = Mth.floor(o - q / 2.0);
+			int v = Mth.floor(m + q / 2.0);
+			int w = Mth.floor(n + r / 2.0);
+			int x = Mth.floor(o + q / 2.0);
 
 			for (int y = s; y <= v; y++) {
 				double z = ((double)y + 0.5 - m) / (q / 2.0);
 				if (z * z < 1.0) {
 					for (int aa = t; aa <= w; aa++) {
